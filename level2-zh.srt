1
00:00:00,900 --> 00:00:02,030
我是 Gregg Pollack，您正在收看的是

2
00:00:02,030 --> 00:00:03,960
“僵尸学 Rails”第二课

3
00:00:04,790 --> 00:00:07,370
（唱）丢掉手上的脑子和肠子

4
00:00:07,376 --> 00:00:10,400
要停止兽性，学习一点 Rails 知识了

5
00:00:10,400 --> 00:00:13,600
因为我们要与时俱进

6
00:00:13,600 --> 00:00:17,900
这是 Envy Labs 出品的“僵尸学 Rails”教学视频

7
00:00:18,530 --> 00:00:23,780
第二课我们要学习的是“模型”

8
00:00:23,780 --> 00:00:28,040
第一课我们编写了 Tweet.find(3) 这行代码

9
00:00:28,040 --> 00:00:32,320
通过某种方式可以映射到下面这个数据表上

10
00:00:32,320 --> 00:00:37,960
二者之间的对应显然少了根纽带

11
00:00:37,960 --> 00:00:39,800
这根纽带就是“模型”

12
00:00:39,800 --> 00:00:45,580
本例中有个 Tweet 模型，一个普通的 Ruby 类

13
00:00:45,580 --> 00:00:50,830
调用大写的 Tweet 时

14
00:00:50,830 --> 00:00:54,420
会先找到 Tweet 类

15
00:00:54,420 --> 00:00:57,020
Tweet 类继承自 ActiveRecord::Base

16
00:00:57,020 --> 00:00:59,740
简单来说，这层关系会把类和数据表联系起来

17
00:00:59,740 --> 00:01:02,440
因此会在数据库中寻找复数形式

18
00:01:02,440 --> 00:01:06,730
名为 tweets 的数据表，如下所示

19
00:01:06,730 --> 00:01:11,160
我们来仔细分析一下执行查询的过程

20
00:01:11,160 --> 00:01:13,080
我要执行的代码是 Tweet.find(3)

21
00:01:13,080 --> 00:01:15,630
这里的 Tweet 是个类

22
00:01:15,630 --> 00:01:17,900
我们调用 Tweet 类的 find(3) 方法

23
00:01:17,900 --> 00:01:23,070
在数据库中查询 ID 为 3 的记录

24
00:01:23,070 --> 00:01:28,500
得到 Tweet 的一个实例，把获取的数据存入对象

25
00:01:28,500 --> 00:01:31,030
再赋值给变量 t

26
00:01:31,960 --> 00:01:37,390
在第一课中我们得知，不指定数据也可以创建微博

27
00:01:37,390 --> 00:01:42,000
本例我们也可以这么做，但并不友好

28
00:01:42,520 --> 00:01:47,340
显然我们要验证提供给模型的数据

29
00:01:47,340 --> 00:01:50,200
在 Rails 中我们可以添加一些代码做验证

30
00:01:50,530 --> 00:01:52,760
在 Tweet 类中，我们可以添加

31
00:01:52,760 --> 00:01:54,800
validates_presence_of :status

32
00:01:54,800 --> 00:01:59,070
确保保存之前指定了 status 的值

33
00:01:59,350 --> 00:02:03,500
下面来试一下，调用 t = Tweet.new

34
00:02:03,500 --> 00:02:07,260
会得到一个尚未保存的 Tweet 对象

35
00:02:07,260 --> 00:02:09,000
然后再调用 t.save

36
00:02:09,000 --> 00:02:12,400
返回结果是 false，因为无法存入数据库

37
00:02:12,400 --> 00:02:15,030
因为验证未通过

38
00:02:15,030 --> 00:02:19,250
调用 t.errors 会得到一个由错误信息组成的 Hash

39
00:02:19,840 --> 00:02:25,500
调用 t.errors[:status] 则会返回特定属性产生的错误

40
00:02:26,440 --> 00:02:30,400
Rails 内置了大量验证

41
00:02:30,400 --> 00:02:32,890
有数字验证，唯一性验证

42
00:02:32,890 --> 00:02:35,000
二次确认验证，范围验证，长度验证

43
00:02:35,000 --> 00:02:37,060
格式验证，等等

44
00:02:38,350 --> 00:02:41,710
从 Rails 3 开始，可以使用新句法编写验证

45
00:02:41,710 --> 00:02:44,780
一行写一个验证，可以写成

46
00:02:44,780 --> 00:02:48,480
validates :status, :presence => true

47
00:02:48,480 --> 00:02:52,100
这行代码指定了属性和对应的验证规则

48
00:02:52,850 --> 00:02:57,730
接着可以写 validates :status, :length ...

49
00:02:57,730 --> 00:03:02,500
为了简便，还可以合成一行

50
00:03:03,190 --> 00:03:08,200
下面是刚才介绍过的验证，不过换用了新句法

51
00:03:08,830 --> 00:03:11,390
现在要讨论一下“关联”了

52
00:03:11,390 --> 00:03:13,400
你知道的，僵尸总是成群结队

53
00:03:13,400 --> 00:03:18,140
数据库中会有很多表，而且要关联起来

54
00:03:18,410 --> 00:03:21,600
在前面的例子中，你应该注意到了

55
00:03:21,600 --> 00:03:24,720
Ash 这个僵尸发布了两篇微博

56
00:03:24,720 --> 00:03:26,700
他的名字在数据表中存储了两次

57
00:03:26,700 --> 00:03:29,140
这么做显然不高效

58
00:03:29,140 --> 00:03:31,000
现在我们要把 zombies 属性剥离

59
00:03:31,000 --> 00:03:34,000
存入单独的数据表 zombies 中

60
00:03:35,410 --> 00:03:41,040
为此就要知道如何把僵尸和微博对应起来

61
00:03:41,040 --> 00:03:43,820
在 Rails 中这种关联可以通过

62
00:03:43,820 --> 00:03:47,900
在 tweets 表中添加 zombie_ID 属性实现

63
00:03:48,560 --> 00:03:52,030
然后存储发布微博的僵尸 ID

64
00:03:52,030 --> 00:03:54,800
这样微博和僵尸的对应关系就建立起来了

65
00:03:55,810 --> 00:03:58,100
新建一个微博，内容是

66
00:03:58,100 --> 00:03:59,630
Your eyelids taste like bacon

67
00:03:59,630 --> 00:04:03,440
就可以指定是哪个僵尸发布的了

68
00:04:04,660 --> 00:04:09,970
看一下这个数据表，可以说，微博是属于僵尸的

69
00:04:10,770 --> 00:04:13,400
在模型中，要正确地设定关联

70
00:04:13,400 --> 00:04:16,830
只需加入 belongs_to :zombie

71
00:04:17,769 --> 00:04:20,980
一定要注意，这里用的是单数形式

72
00:04:20,980 --> 00:04:27,380
之所以加入这行代码，是因为一篇微博属于一个僵尸

73
00:04:27,380 --> 00:04:29,800
现在只做了单边关联

74
00:04:29,800 --> 00:04:32,300
另外一边的关联怎么设定呢

75
00:04:32,300 --> 00:04:38,100
也就是一个僵尸拥有多篇微博

76
00:04:38,810 --> 00:04:41,470
如果你换个角度，就可以看出

77
00:04:41,470 --> 00:04:45,100
只需加入 has_many :tweets

78
00:04:45,570 --> 00:04:48,830
至此，这两个模型间的关联就建立好了

79
00:04:48,830 --> 00:04:51,050
我们在控制台中玩一会

80
00:04:51,210 --> 00:04:56,100
我们要找一个僵尸，为其创建一篇微博

81
00:04:56,100 --> 00:04:58,540
我们调用 Tweet.create

82
00:04:58,540 --> 00:05:02,180
指定 status 的值和僵尸的 ID

83
00:05:03,180 --> 00:05:04,800
注意，在第二行代码中

84
00:05:04,800 --> 00:05:08,100
微博成功保存并赋值给了变量 t

85
00:05:08,100 --> 00:05:10,600
之后，可以调用 t.zombie

86
00:05:10,600 --> 00:05:13,530
获取发布该微博的僵尸对象

87
00:05:13,530 --> 00:05:17,600
调用 t.zombie.name 输出发布该微博的

88
00:05:17,600 --> 00:05:19,500
僵尸名字，也就是 Bob

89
00:05:20,660 --> 00:05:25,360
要查看关联的另一边，可以先读取一个僵尸

90
00:05:27,300 --> 00:05:29,730
我们可以统计该僵尸发布的微博数

91
00:05:29,730 --> 00:05:33,900
如果直接调用 ash.tweets，会得到一个数组

92
00:05:33,900 --> 00:05:36,600
包含该僵尸发布的所有微博

93
00:05:37,090 --> 00:05:40,900
课后要练习一下本课所学的代码哟

94
00:05:40,900 --> 00:05:45,330
翻译制作：@andor_chen on Twitter

